{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { memo, useCallback, useState, useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Transition } from 'react-transition-group';\nimport { StackingOrder, Position } from '../../constants';\nimport { useMergedRef, usePrevious } from '../../hooks';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport getPosition from './getPosition';\nvar animationEasing = {\n  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'\n};\n\nvar getCSS = function getCSS(_ref) {\n  var animationDuration = _ref.animationDuration,\n      initialScale = _ref.initialScale;\n  return {\n    position: 'fixed',\n    opacity: 0,\n    transitionTimingFunction: animationEasing.spring,\n    transitionDuration: \"\".concat(animationDuration, \"ms\"),\n    transitionProperty: 'opacity, transform',\n    transform: \"scale(\".concat(initialScale, \") translateY(-1px)\"),\n    '&[data-state=\"entering\"], &[data-state=\"entered\"]': {\n      opacity: 1,\n      visibility: 'visible',\n      transform: 'scale(1)'\n    },\n    '&[data-state=\"exiting\"]': {\n      opacity: 0,\n      transform: 'scale(1)'\n    }\n  };\n};\n\nvar noop = function noop() {};\n\nvar initialDimensions = {\n  left: 0,\n  top: 0,\n  height: 0,\n  width: 0,\n  transformOrigin: null\n};\nvar Positioner = /*#__PURE__*/memo(function Positioner(props) {\n  var target = props.target,\n      isShown = props.isShown,\n      children = props.children,\n      _props$initialScale = props.initialScale,\n      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,\n      _props$animationDurat = props.animationDuration,\n      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,\n      _props$position = props.position,\n      position = _props$position === void 0 ? Position.BOTTOM : _props$position,\n      _props$bodyOffset = props.bodyOffset,\n      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,\n      _props$targetOffset = props.targetOffset,\n      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,\n      _props$onOpenComplete = props.onOpenComplete,\n      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,\n      _props$onCloseComplet = props.onCloseComplete,\n      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;\n\n  var _useState = useState(initialDimensions),\n      _useState2 = _slicedToArray(_useState, 2),\n      dimensions = _useState2[0],\n      setDimensions = _useState2[1];\n\n  var previousDimensions = usePrevious(dimensions, initialDimensions);\n  var latestAnimationFrame = useRef();\n  var transitionState = useRef();\n  var positionerRef = useRef();\n  var targetRef = useRef();\n  var setTargetRef = useMergedRef(targetRef);\n  var getRef = useMergedRef(positionerRef);\n  var update = useCallback(function () {\n    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (!isShown || !targetRef.current || !positionerRef.current) return;\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';\n    var viewportHeight = document.documentElement.clientHeight;\n    var viewportWidth = document.documentElement.clientWidth;\n    var height;\n    var width;\n\n    if (hasEntered) {\n      // Only when the animation is done should we opt-in to `getBoundingClientRect`\n      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255\n      // We need to ceil the width and height to prevent jitter when\n      // the window is zoomed (when `window.devicePixelRatio` is not an integer)\n\n      height = Math.round(positionerRect.height);\n      width = Math.round(positionerRect.width);\n    } else {\n      // When the animation is in flight use `offsetWidth/Height` which\n      // does not calculate the `transform` property as part of its result.\n      // There is still change on jitter during the animation (although unoticable)\n      // When the browser is zoomed in — we fix this with `Math.max`.\n      height = Math.max(positionerRef.current.offsetHeight, prevHeight);\n      width = Math.max(positionerRef.current.offsetWidth, prevWidth);\n    }\n\n    var _getPosition = getPosition({\n      position: position,\n      targetRect: targetRect,\n      targetOffset: targetOffset,\n      dimensions: {\n        height: height,\n        width: width\n      },\n      viewport: {\n        width: viewportWidth,\n        height: viewportHeight\n      },\n      viewportOffset: bodyOffset\n    }),\n        rect = _getPosition.rect,\n        transformOrigin = _getPosition.transformOrigin;\n\n    setDimensions({\n      left: rect.left,\n      top: rect.top,\n      height: height,\n      width: width,\n      transformOrigin: transformOrigin\n    });\n  }, [bodyOffset, isShown, position, targetOffset]); // Call `update` whenever the component has \"entered\" and dimensions change\n  // additionally, when there are dynamic children\n\n  useEffect(function () {\n    if (transitionState.current === 'entered') {\n      latestAnimationFrame.current = requestAnimationFrame(function () {\n        update(previousDimensions.height, previousDimensions.width);\n      });\n    }\n\n    return function () {\n      if (latestAnimationFrame.current) {\n        cancelAnimationFrame(latestAnimationFrame.current);\n      }\n    };\n  }, [previousDimensions.height, previousDimensions.width, update, children]);\n\n  var handleEntering = function handleEntering() {\n    transitionState.current = 'entering';\n    update();\n  };\n\n  var handleEnter = function handleEnter() {\n    transitionState.current = 'entered';\n    update();\n  };\n\n  var handleExited = function handleExited() {\n    transitionState.current = 'exited';\n    setDimensions(initialDimensions);\n    onCloseComplete();\n  };\n\n  useEffect(function () {\n    window.addEventListener('resize', update);\n    window.addEventListener('scroll', update);\n    return function () {\n      window.removeEventListener('resize', update);\n      window.removeEventListener('scroll', update);\n    };\n  });\n  return /*#__PURE__*/React.createElement(Stack, {\n    value: StackingOrder.POSITIONER\n  }, function (zIndex) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, target({\n      getRef: setTargetRef,\n      isShown: isShown\n    }), /*#__PURE__*/React.createElement(Transition, {\n      nodeRef: positionerRef,\n      appear: true,\n      \"in\": isShown,\n      timeout: animationDuration,\n      onEnter: handleEnter,\n      onEntering: handleEntering,\n      onEntered: onOpenComplete,\n      onExited: handleExited,\n      unmountOnExit: true\n    }, function (state) {\n      return /*#__PURE__*/React.createElement(Portal, null, children({\n        top: dimensions.top,\n        left: dimensions.left,\n        state: state,\n        zIndex: zIndex,\n        css: getCSS({\n          initialScale: initialScale,\n          animationDuration: animationDuration\n        }),\n        style: {\n          transformOrigin: dimensions.transformOrigin,\n          left: dimensions.left,\n          top: dimensions.top,\n          zIndex: zIndex\n        },\n        getRef: getRef,\n        animationDuration: animationDuration\n      }));\n    }));\n  });\n});\nPositioner.propTypes = {\n  /**\n   * The position the element that is being positioned is on.\n   * Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * When true, show the element being positioned.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * Function that returns the element being positioned.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * The minimum distance from the body to the element being positioned.\n   */\n  bodyOffset: PropTypes.number,\n\n  /**\n   * The minimum distance from the target to the element being positioned.\n   */\n  targetOffset: PropTypes.number,\n\n  /**\n   * Function that should return a node for the target.\n   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node\n   */\n  target: PropTypes.func.isRequired,\n\n  /**\n   * Initial scale of the element being positioned.\n   */\n  initialScale: PropTypes.number,\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func\n};\nexport default Positioner;","map":{"version":3,"sources":["D:/study/WifiAssistant/WifiAssistant/node_modules/evergreen-ui/esm/positioner/src/Positioner.js"],"names":["_slicedToArray","React","memo","useCallback","useState","useEffect","useRef","PropTypes","Transition","StackingOrder","Position","useMergedRef","usePrevious","Portal","Stack","getPosition","animationEasing","spring","getCSS","_ref","animationDuration","initialScale","position","opacity","transitionTimingFunction","transitionDuration","concat","transitionProperty","transform","visibility","noop","initialDimensions","left","top","height","width","transformOrigin","Positioner","props","target","isShown","children","_props$initialScale","_props$animationDurat","_props$position","BOTTOM","_props$bodyOffset","bodyOffset","_props$targetOffset","targetOffset","_props$onOpenComplete","onOpenComplete","_props$onCloseComplet","onCloseComplete","_useState","_useState2","dimensions","setDimensions","previousDimensions","latestAnimationFrame","transitionState","positionerRef","targetRef","setTargetRef","getRef","update","prevHeight","arguments","length","undefined","prevWidth","current","targetRect","getBoundingClientRect","hasEntered","getAttribute","viewportHeight","document","documentElement","clientHeight","viewportWidth","clientWidth","positionerRect","Math","round","max","offsetHeight","offsetWidth","_getPosition","viewport","viewportOffset","rect","requestAnimationFrame","cancelAnimationFrame","handleEntering","handleEnter","handleExited","window","addEventListener","removeEventListener","createElement","value","POSITIONER","zIndex","Fragment","nodeRef","appear","timeout","onEnter","onEntering","onEntered","onExited","unmountOnExit","state","css","style","propTypes","oneOf","TOP","TOP_LEFT","TOP_RIGHT","BOTTOM_LEFT","BOTTOM_RIGHT","LEFT","RIGHT","bool","func","isRequired","number"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { memo, useCallback, useState, useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Transition } from 'react-transition-group';\nimport { StackingOrder, Position } from '../../constants';\nimport { useMergedRef, usePrevious } from '../../hooks';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport getPosition from './getPosition';\nvar animationEasing = {\n  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'\n};\n\nvar getCSS = function getCSS(_ref) {\n  var animationDuration = _ref.animationDuration,\n      initialScale = _ref.initialScale;\n  return {\n    position: 'fixed',\n    opacity: 0,\n    transitionTimingFunction: animationEasing.spring,\n    transitionDuration: \"\".concat(animationDuration, \"ms\"),\n    transitionProperty: 'opacity, transform',\n    transform: \"scale(\".concat(initialScale, \") translateY(-1px)\"),\n    '&[data-state=\"entering\"], &[data-state=\"entered\"]': {\n      opacity: 1,\n      visibility: 'visible',\n      transform: 'scale(1)'\n    },\n    '&[data-state=\"exiting\"]': {\n      opacity: 0,\n      transform: 'scale(1)'\n    }\n  };\n};\n\nvar noop = function noop() {};\n\nvar initialDimensions = {\n  left: 0,\n  top: 0,\n  height: 0,\n  width: 0,\n  transformOrigin: null\n};\nvar Positioner = /*#__PURE__*/memo(function Positioner(props) {\n  var target = props.target,\n      isShown = props.isShown,\n      children = props.children,\n      _props$initialScale = props.initialScale,\n      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,\n      _props$animationDurat = props.animationDuration,\n      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,\n      _props$position = props.position,\n      position = _props$position === void 0 ? Position.BOTTOM : _props$position,\n      _props$bodyOffset = props.bodyOffset,\n      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,\n      _props$targetOffset = props.targetOffset,\n      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,\n      _props$onOpenComplete = props.onOpenComplete,\n      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,\n      _props$onCloseComplet = props.onCloseComplete,\n      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;\n\n  var _useState = useState(initialDimensions),\n      _useState2 = _slicedToArray(_useState, 2),\n      dimensions = _useState2[0],\n      setDimensions = _useState2[1];\n\n  var previousDimensions = usePrevious(dimensions, initialDimensions);\n  var latestAnimationFrame = useRef();\n  var transitionState = useRef();\n  var positionerRef = useRef();\n  var targetRef = useRef();\n  var setTargetRef = useMergedRef(targetRef);\n  var getRef = useMergedRef(positionerRef);\n  var update = useCallback(function () {\n    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (!isShown || !targetRef.current || !positionerRef.current) return;\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';\n    var viewportHeight = document.documentElement.clientHeight;\n    var viewportWidth = document.documentElement.clientWidth;\n    var height;\n    var width;\n\n    if (hasEntered) {\n      // Only when the animation is done should we opt-in to `getBoundingClientRect`\n      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255\n      // We need to ceil the width and height to prevent jitter when\n      // the window is zoomed (when `window.devicePixelRatio` is not an integer)\n\n      height = Math.round(positionerRect.height);\n      width = Math.round(positionerRect.width);\n    } else {\n      // When the animation is in flight use `offsetWidth/Height` which\n      // does not calculate the `transform` property as part of its result.\n      // There is still change on jitter during the animation (although unoticable)\n      // When the browser is zoomed in — we fix this with `Math.max`.\n      height = Math.max(positionerRef.current.offsetHeight, prevHeight);\n      width = Math.max(positionerRef.current.offsetWidth, prevWidth);\n    }\n\n    var _getPosition = getPosition({\n      position: position,\n      targetRect: targetRect,\n      targetOffset: targetOffset,\n      dimensions: {\n        height: height,\n        width: width\n      },\n      viewport: {\n        width: viewportWidth,\n        height: viewportHeight\n      },\n      viewportOffset: bodyOffset\n    }),\n        rect = _getPosition.rect,\n        transformOrigin = _getPosition.transformOrigin;\n\n    setDimensions({\n      left: rect.left,\n      top: rect.top,\n      height: height,\n      width: width,\n      transformOrigin: transformOrigin\n    });\n  }, [bodyOffset, isShown, position, targetOffset]); // Call `update` whenever the component has \"entered\" and dimensions change\n  // additionally, when there are dynamic children\n\n  useEffect(function () {\n    if (transitionState.current === 'entered') {\n      latestAnimationFrame.current = requestAnimationFrame(function () {\n        update(previousDimensions.height, previousDimensions.width);\n      });\n    }\n\n    return function () {\n      if (latestAnimationFrame.current) {\n        cancelAnimationFrame(latestAnimationFrame.current);\n      }\n    };\n  }, [previousDimensions.height, previousDimensions.width, update, children]);\n\n  var handleEntering = function handleEntering() {\n    transitionState.current = 'entering';\n    update();\n  };\n\n  var handleEnter = function handleEnter() {\n    transitionState.current = 'entered';\n    update();\n  };\n\n  var handleExited = function handleExited() {\n    transitionState.current = 'exited';\n    setDimensions(initialDimensions);\n    onCloseComplete();\n  };\n\n  useEffect(function () {\n    window.addEventListener('resize', update);\n    window.addEventListener('scroll', update);\n    return function () {\n      window.removeEventListener('resize', update);\n      window.removeEventListener('scroll', update);\n    };\n  });\n  return /*#__PURE__*/React.createElement(Stack, {\n    value: StackingOrder.POSITIONER\n  }, function (zIndex) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, target({\n      getRef: setTargetRef,\n      isShown: isShown\n    }), /*#__PURE__*/React.createElement(Transition, {\n      nodeRef: positionerRef,\n      appear: true,\n      \"in\": isShown,\n      timeout: animationDuration,\n      onEnter: handleEnter,\n      onEntering: handleEntering,\n      onEntered: onOpenComplete,\n      onExited: handleExited,\n      unmountOnExit: true\n    }, function (state) {\n      return /*#__PURE__*/React.createElement(Portal, null, children({\n        top: dimensions.top,\n        left: dimensions.left,\n        state: state,\n        zIndex: zIndex,\n        css: getCSS({\n          initialScale: initialScale,\n          animationDuration: animationDuration\n        }),\n        style: {\n          transformOrigin: dimensions.transformOrigin,\n          left: dimensions.left,\n          top: dimensions.top,\n          zIndex: zIndex\n        },\n        getRef: getRef,\n        animationDuration: animationDuration\n      }));\n    }));\n  });\n});\nPositioner.propTypes = {\n  /**\n   * The position the element that is being positioned is on.\n   * Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * When true, show the element being positioned.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * Function that returns the element being positioned.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * The minimum distance from the body to the element being positioned.\n   */\n  bodyOffset: PropTypes.number,\n\n  /**\n   * The minimum distance from the target to the element being positioned.\n   */\n  targetOffset: PropTypes.number,\n\n  /**\n   * Function that should return a node for the target.\n   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node\n   */\n  target: PropTypes.func.isRequired,\n\n  /**\n   * Initial scale of the element being positioned.\n   */\n  initialScale: PropTypes.number,\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func\n};\nexport default Positioner;"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
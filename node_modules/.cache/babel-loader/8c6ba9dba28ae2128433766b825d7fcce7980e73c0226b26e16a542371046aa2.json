{"ast":null,"code":"import { Position } from '../../constants';\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\n\nvar makeRect = function makeRect(_ref, _ref2) {\n  var height = _ref.height,\n      width = _ref.width;\n  var left = _ref2.left,\n      top = _ref2.top;\n  var ceiledLeft = Math.ceil(left);\n  var ceiledTop = Math.ceil(top);\n  return {\n    width: width,\n    height: height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  };\n};\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\n\n\nvar flipHorizontal = function flipHorizontal(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT;\n\n    case Position.TOP:\n    default:\n      return Position.BOTTOM;\n\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT;\n\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT;\n\n    case Position.BOTTOM:\n      return Position.TOP;\n\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT;\n  }\n};\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedOnTop = function isAlignedOnTop(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedHorizontal = function isAlignedHorizontal(position) {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {\n  return rect.bottom < viewport.height - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {\n  return rect.top > viewportOffset;\n};\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {\n  return rect.right < viewport.width - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {\n  return rect.left > viewportOffset;\n};\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\n\n\nvar getTransformOrigin = function getTransformOrigin(_ref3) {\n  var dimensions = _ref3.dimensions,\n      position = _ref3.position,\n      rect = _ref3.rect,\n      targetCenter = _ref3.targetCenter;\n  var centerY = Math.round(targetCenter - rect.top);\n\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(dimensions.width, \"px \").concat(centerY, \"px\");\n  }\n\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return \"0px \".concat(centerY, \"px\");\n  }\n\n  var centerX = Math.round(targetCenter - rect.left);\n\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(centerX, \"px \").concat(dimensions.height, \"px \");\n  }\n  /* Syntax: x-offset | y-offset */\n\n\n  return \"\".concat(centerX, \"px 0px \");\n};\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Number} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position, transformOrigin: string }\n */\n\n\nexport default function getFittedPosition(_ref4) {\n  var dimensions = _ref4.dimensions,\n      position = _ref4.position,\n      targetOffset = _ref4.targetOffset,\n      targetRect = _ref4.targetRect,\n      viewport = _ref4.viewport,\n      _ref4$viewportOffset = _ref4.viewportOffset,\n      viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;\n\n  var _getPosition = getPosition({\n    position: position,\n    dimensions: dimensions,\n    targetRect: targetRect,\n    targetOffset: targetOffset,\n    viewport: viewport,\n    viewportOffset: viewportOffset\n  }),\n      finalPosition = _getPosition.position,\n      rect = _getPosition.rect; // Push rect to the right if overflowing on the left side of the viewport.\n\n\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));\n    rect.left = Math.ceil(viewportOffset);\n  } // Push rect to the left if overflowing on the right side of the viewport.\n\n\n  if (rect.right > viewport.width - viewportOffset) {\n    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));\n    rect.left -= delta;\n    rect.right -= delta;\n  } // Push rect down if overflowing on the top side of the viewport.\n\n\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));\n    rect.bottom = Math.ceil(viewportOffset);\n  } // Push rect up if overflowing on the bottom side of the viewport.\n\n\n  if (rect.bottom > viewport.height - viewportOffset) {\n    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));\n\n    rect.top -= _delta;\n    rect.bottom -= _delta;\n  }\n\n  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;\n  var transformOrigin = getTransformOrigin({\n    rect: rect,\n    position: finalPosition,\n    dimensions: dimensions,\n    targetCenter: targetCenter\n  });\n  return {\n    rect: rect,\n    position: finalPosition,\n    transformOrigin: transformOrigin\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\n\nfunction getPosition(_ref5) {\n  var dimensions = _ref5.dimensions,\n      position = _ref5.position,\n      targetOffset = _ref5.targetOffset,\n      targetRect = _ref5.targetRect,\n      viewport = _ref5.viewport,\n      _ref5$viewportOffset = _ref5.viewportOffset,\n      viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;\n  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions\n\n  if (isHorizontal) {\n    var leftRect = getRect({\n      position: Position.LEFT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);\n    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);\n\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position: position,\n          rect: leftRect\n        };\n      }\n\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        };\n      }\n    }\n\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position: position,\n          rect: rightRect\n        };\n      }\n\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        };\n      }\n    } // Default to using the position with the most space\n\n\n    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);\n    var spaceLeft = Math.abs(leftRect.left - viewportOffset);\n\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      };\n    }\n\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    };\n  }\n\n  var positionIsAlignedOnTop = isAlignedOnTop(position);\n  var topRect;\n  var bottomRect;\n\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  }\n\n  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);\n  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);\n\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position: position,\n        rect: topRect\n      };\n    }\n\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      };\n    }\n  }\n\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: position,\n        rect: bottomRect\n      };\n    }\n\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      };\n    }\n  } // Default to most spacious if there is no fit.\n\n\n  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);\n  var spaceTop = Math.abs(topRect.top - viewportOffset);\n\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    };\n  }\n\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @return {Rect} - Rect { width, height, left, top, right, bottom }\n */\n\n\nfunction getRect(_ref6) {\n  var dimensions = _ref6.dimensions,\n      position = _ref6.position,\n      targetOffset = _ref6.targetOffset,\n      targetRect = _ref6.targetRect;\n  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;\n  var alignedTopY = targetRect.top - dimensions.height - targetOffset;\n  var alignedBottomY = targetRect.bottom + targetOffset;\n  var alignedRightX = targetRect.right - dimensions.width;\n  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;\n\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      });\n\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      });\n\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      });\n\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      });\n  }\n}","map":{"version":3,"sources":["D:/study/WifiAssistant/WifiAssistant/node_modules/evergreen-ui/esm/positioner/src/getPosition.js"],"names":["Position","makeRect","_ref","_ref2","height","width","left","top","ceiledLeft","Math","ceil","ceiledTop","right","bottom","flipHorizontal","position","TOP_LEFT","BOTTOM_LEFT","TOP","BOTTOM","TOP_RIGHT","BOTTOM_RIGHT","isAlignedOnTop","isAlignedHorizontal","LEFT","RIGHT","getFitsOnBottom","rect","viewport","viewportOffset","getFitsOnTop","getFitsOnRight","getFitsOnLeft","getTransformOrigin","_ref3","dimensions","targetCenter","centerY","round","concat","centerX","getFittedPosition","_ref4","targetOffset","targetRect","_ref4$viewportOffset","_getPosition","getPosition","finalPosition","abs","delta","_delta","transformOrigin","_ref5","_ref5$viewportOffset","isHorizontal","leftRect","getRect","rightRect","fitsOnLeft","fitsOnRight","spaceRight","spaceLeft","positionIsAlignedOnTop","topRect","bottomRect","topRectFitsOnTop","bottomRectFitsOnBottom","spaceBottom","spaceTop","_ref6","alignedTopY","alignedBottomY","alignedRightX","alignedLeftRightY"],"mappings":"AAAA,SAASA,QAAT,QAAyB,iBAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,KAAxB,EAA+B;AAC5C,MAAIC,MAAM,GAAGF,IAAI,CAACE,MAAlB;AAAA,MACIC,KAAK,GAAGH,IAAI,CAACG,KADjB;AAEA,MAAIC,IAAI,GAAGH,KAAK,CAACG,IAAjB;AAAA,MACIC,GAAG,GAAGJ,KAAK,CAACI,GADhB;AAEA,MAAIC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUJ,IAAV,CAAjB;AACA,MAAIK,SAAS,GAAGF,IAAI,CAACC,IAAL,CAAUH,GAAV,CAAhB;AACA,SAAO;AACLF,IAAAA,KAAK,EAAEA,KADF;AAELD,IAAAA,MAAM,EAAEA,MAFH;AAGLE,IAAAA,IAAI,EAAEE,UAHD;AAILD,IAAAA,GAAG,EAAEI,SAJA;AAKLC,IAAAA,KAAK,EAAEJ,UAAU,GAAGH,KALf;AAMLQ,IAAAA,MAAM,EAAEF,SAAS,GAAGP;AANf,GAAP;AAQD,CAfD;AAgBA;AACA;AACA;AACA;AACA;;;AAGA,IAAIU,cAAc,GAAG,SAASA,cAAT,CAAwBC,QAAxB,EAAkC;AACrD,UAAQA,QAAR;AACE,SAAKf,QAAQ,CAACgB,QAAd;AACE,aAAOhB,QAAQ,CAACiB,WAAhB;;AAEF,SAAKjB,QAAQ,CAACkB,GAAd;AACA;AACE,aAAOlB,QAAQ,CAACmB,MAAhB;;AAEF,SAAKnB,QAAQ,CAACoB,SAAd;AACE,aAAOpB,QAAQ,CAACqB,YAAhB;;AAEF,SAAKrB,QAAQ,CAACiB,WAAd;AACE,aAAOjB,QAAQ,CAACgB,QAAhB;;AAEF,SAAKhB,QAAQ,CAACmB,MAAd;AACE,aAAOnB,QAAQ,CAACkB,GAAhB;;AAEF,SAAKlB,QAAQ,CAACqB,YAAd;AACE,aAAOrB,QAAQ,CAACoB,SAAhB;AAlBJ;AAoBD,CArBD;AAsBA;AACA;AACA;AACA;AACA;;;AAGA,IAAIE,cAAc,GAAG,SAASA,cAAT,CAAwBP,QAAxB,EAAkC;AACrD,UAAQA,QAAR;AACE,SAAKf,QAAQ,CAACgB,QAAd;AACA,SAAKhB,QAAQ,CAACkB,GAAd;AACA,SAAKlB,QAAQ,CAACoB,SAAd;AACE,aAAO,IAAP;;AAEF;AACE,aAAO,KAAP;AAPJ;AASD,CAVD;AAWA;AACA;AACA;AACA;AACA;;;AAGA,IAAIG,mBAAmB,GAAG,SAASA,mBAAT,CAA6BR,QAA7B,EAAuC;AAC/D,UAAQA,QAAR;AACE,SAAKf,QAAQ,CAACwB,IAAd;AACA,SAAKxB,QAAQ,CAACyB,KAAd;AACE,aAAO,IAAP;;AAEF;AACE,aAAO,KAAP;AANJ;AAQD,CATD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAIC,eAAe,GAAG,SAASA,eAAT,CAAyBC,IAAzB,EAA+BC,QAA/B,EAAyCC,cAAzC,EAAyD;AAC7E,SAAOF,IAAI,CAACd,MAAL,GAAce,QAAQ,CAACxB,MAAT,GAAkByB,cAAvC;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAIC,YAAY,GAAG,SAASA,YAAT,CAAsBH,IAAtB,EAA4BE,cAA5B,EAA4C;AAC7D,SAAOF,IAAI,CAACpB,GAAL,GAAWsB,cAAlB;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAIE,cAAc,GAAG,SAASA,cAAT,CAAwBJ,IAAxB,EAA8BC,QAA9B,EAAwCC,cAAxC,EAAwD;AAC3E,SAAOF,IAAI,CAACf,KAAL,GAAagB,QAAQ,CAACvB,KAAT,GAAiBwB,cAArC;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAIG,aAAa,GAAG,SAASA,aAAT,CAAuBL,IAAvB,EAA6BE,cAA7B,EAA6C;AAC/D,SAAOF,IAAI,CAACrB,IAAL,GAAYuB,cAAnB;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAII,kBAAkB,GAAG,SAASA,kBAAT,CAA4BC,KAA5B,EAAmC;AAC1D,MAAIC,UAAU,GAAGD,KAAK,CAACC,UAAvB;AAAA,MACIpB,QAAQ,GAAGmB,KAAK,CAACnB,QADrB;AAAA,MAEIY,IAAI,GAAGO,KAAK,CAACP,IAFjB;AAAA,MAGIS,YAAY,GAAGF,KAAK,CAACE,YAHzB;AAIA,MAAIC,OAAO,GAAG5B,IAAI,CAAC6B,KAAL,CAAWF,YAAY,GAAGT,IAAI,CAACpB,GAA/B,CAAd;;AAEA,MAAIQ,QAAQ,KAAKf,QAAQ,CAACwB,IAA1B,EAAgC;AAC9B;AACA,WAAO,GAAGe,MAAH,CAAUJ,UAAU,CAAC9B,KAArB,EAA4B,KAA5B,EAAmCkC,MAAnC,CAA0CF,OAA1C,EAAmD,IAAnD,CAAP;AACD;;AAED,MAAItB,QAAQ,KAAKf,QAAQ,CAACyB,KAA1B,EAAiC;AAC/B;AACA,WAAO,OAAOc,MAAP,CAAcF,OAAd,EAAuB,IAAvB,CAAP;AACD;;AAED,MAAIG,OAAO,GAAG/B,IAAI,CAAC6B,KAAL,CAAWF,YAAY,GAAGT,IAAI,CAACrB,IAA/B,CAAd;;AAEA,MAAIgB,cAAc,CAACP,QAAD,CAAlB,EAA8B;AAC5B;AACA,WAAO,GAAGwB,MAAH,CAAUC,OAAV,EAAmB,KAAnB,EAA0BD,MAA1B,CAAiCJ,UAAU,CAAC/B,MAA5C,EAAoD,KAApD,CAAP;AACD;AACD;;;AAGA,SAAO,GAAGmC,MAAH,CAAUC,OAAV,EAAmB,SAAnB,CAAP;AACD,CA3BD;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,eAAe,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAC/C,MAAIP,UAAU,GAAGO,KAAK,CAACP,UAAvB;AAAA,MACIpB,QAAQ,GAAG2B,KAAK,CAAC3B,QADrB;AAAA,MAEI4B,YAAY,GAAGD,KAAK,CAACC,YAFzB;AAAA,MAGIC,UAAU,GAAGF,KAAK,CAACE,UAHvB;AAAA,MAIIhB,QAAQ,GAAGc,KAAK,CAACd,QAJrB;AAAA,MAKIiB,oBAAoB,GAAGH,KAAK,CAACb,cALjC;AAAA,MAMIA,cAAc,GAAGgB,oBAAoB,KAAK,KAAK,CAA9B,GAAkC,CAAlC,GAAsCA,oBAN3D;;AAQA,MAAIC,YAAY,GAAGC,WAAW,CAAC;AAC7BhC,IAAAA,QAAQ,EAAEA,QADmB;AAE7BoB,IAAAA,UAAU,EAAEA,UAFiB;AAG7BS,IAAAA,UAAU,EAAEA,UAHiB;AAI7BD,IAAAA,YAAY,EAAEA,YAJe;AAK7Bf,IAAAA,QAAQ,EAAEA,QALmB;AAM7BC,IAAAA,cAAc,EAAEA;AANa,GAAD,CAA9B;AAAA,MAQImB,aAAa,GAAGF,YAAY,CAAC/B,QARjC;AAAA,MASIY,IAAI,GAAGmB,YAAY,CAACnB,IATxB,CAT+C,CAkBjB;;;AAG9B,MAAIA,IAAI,CAACrB,IAAL,GAAYuB,cAAhB,EAAgC;AAC9BF,IAAAA,IAAI,CAACf,KAAL,IAAcH,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACwC,GAAL,CAAStB,IAAI,CAACrB,IAAL,GAAYuB,cAArB,CAAV,CAAd;AACAF,IAAAA,IAAI,CAACrB,IAAL,GAAYG,IAAI,CAACC,IAAL,CAAUmB,cAAV,CAAZ;AACD,GAxB8C,CAwB7C;;;AAGF,MAAIF,IAAI,CAACf,KAAL,GAAagB,QAAQ,CAACvB,KAAT,GAAiBwB,cAAlC,EAAkD;AAChD,QAAIqB,KAAK,GAAGzC,IAAI,CAACC,IAAL,CAAUiB,IAAI,CAACf,KAAL,IAAcgB,QAAQ,CAACvB,KAAT,GAAiBwB,cAA/B,CAAV,CAAZ;AACAF,IAAAA,IAAI,CAACrB,IAAL,IAAa4C,KAAb;AACAvB,IAAAA,IAAI,CAACf,KAAL,IAAcsC,KAAd;AACD,GA/B8C,CA+B7C;;;AAGF,MAAIvB,IAAI,CAACpB,GAAL,GAAWsB,cAAf,EAA+B;AAC7BF,IAAAA,IAAI,CAACpB,GAAL,IAAYE,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACwC,GAAL,CAAStB,IAAI,CAACpB,GAAL,GAAWsB,cAApB,CAAV,CAAZ;AACAF,IAAAA,IAAI,CAACd,MAAL,GAAcJ,IAAI,CAACC,IAAL,CAAUmB,cAAV,CAAd;AACD,GArC8C,CAqC7C;;;AAGF,MAAIF,IAAI,CAACd,MAAL,GAAce,QAAQ,CAACxB,MAAT,GAAkByB,cAApC,EAAoD;AAClD,QAAIsB,MAAM,GAAG1C,IAAI,CAACC,IAAL,CAAUiB,IAAI,CAACd,MAAL,IAAee,QAAQ,CAACxB,MAAT,GAAkByB,cAAjC,CAAV,CAAb;;AAEAF,IAAAA,IAAI,CAACpB,GAAL,IAAY4C,MAAZ;AACAxB,IAAAA,IAAI,CAACd,MAAL,IAAesC,MAAf;AACD;;AAED,MAAIf,YAAY,GAAGb,mBAAmB,CAACR,QAAD,CAAnB,GAAgC6B,UAAU,CAACrC,GAAX,GAAiBqC,UAAU,CAACxC,MAAX,GAAoB,CAArE,GAAyEwC,UAAU,CAACtC,IAAX,GAAkBsC,UAAU,CAACvC,KAAX,GAAmB,CAAjI;AACA,MAAI+C,eAAe,GAAGnB,kBAAkB,CAAC;AACvCN,IAAAA,IAAI,EAAEA,IADiC;AAEvCZ,IAAAA,QAAQ,EAAEiC,aAF6B;AAGvCb,IAAAA,UAAU,EAAEA,UAH2B;AAIvCC,IAAAA,YAAY,EAAEA;AAJyB,GAAD,CAAxC;AAMA,SAAO;AACLT,IAAAA,IAAI,EAAEA,IADD;AAELZ,IAAAA,QAAQ,EAAEiC,aAFL;AAGLI,IAAAA,eAAe,EAAEA;AAHZ,GAAP;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASL,WAAT,CAAqBM,KAArB,EAA4B;AAC1B,MAAIlB,UAAU,GAAGkB,KAAK,CAAClB,UAAvB;AAAA,MACIpB,QAAQ,GAAGsC,KAAK,CAACtC,QADrB;AAAA,MAEI4B,YAAY,GAAGU,KAAK,CAACV,YAFzB;AAAA,MAGIC,UAAU,GAAGS,KAAK,CAACT,UAHvB;AAAA,MAIIhB,QAAQ,GAAGyB,KAAK,CAACzB,QAJrB;AAAA,MAKI0B,oBAAoB,GAAGD,KAAK,CAACxB,cALjC;AAAA,MAMIA,cAAc,GAAGyB,oBAAoB,KAAK,KAAK,CAA9B,GAAkC,CAAlC,GAAsCA,oBAN3D;AAOA,MAAIC,YAAY,GAAGhC,mBAAmB,CAACR,QAAD,CAAtC,CAR0B,CAQwB;;AAElD,MAAIwC,YAAJ,EAAkB;AAChB,QAAIC,QAAQ,GAAGC,OAAO,CAAC;AACrB1C,MAAAA,QAAQ,EAAEf,QAAQ,CAACwB,IADE;AAErBW,MAAAA,UAAU,EAAEA,UAFS;AAGrBS,MAAAA,UAAU,EAAEA,UAHS;AAIrBD,MAAAA,YAAY,EAAEA;AAJO,KAAD,CAAtB;AAMA,QAAIe,SAAS,GAAGD,OAAO,CAAC;AACtB1C,MAAAA,QAAQ,EAAEf,QAAQ,CAACyB,KADG;AAEtBU,MAAAA,UAAU,EAAEA,UAFU;AAGtBS,MAAAA,UAAU,EAAEA,UAHU;AAItBD,MAAAA,YAAY,EAAEA;AAJQ,KAAD,CAAvB;AAMA,QAAIgB,UAAU,GAAG3B,aAAa,CAACwB,QAAD,EAAW3B,cAAX,CAA9B;AACA,QAAI+B,WAAW,GAAG7B,cAAc,CAAC2B,SAAD,EAAY9B,QAAZ,EAAsBC,cAAtB,CAAhC;;AAEA,QAAId,QAAQ,KAAKf,QAAQ,CAACwB,IAA1B,EAAgC;AAC9B,UAAImC,UAAJ,EAAgB;AACd,eAAO;AACL5C,UAAAA,QAAQ,EAAEA,QADL;AAELY,UAAAA,IAAI,EAAE6B;AAFD,SAAP;AAID;;AAED,UAAII,WAAJ,EAAiB;AACf,eAAO;AACL7C,UAAAA,QAAQ,EAAEf,QAAQ,CAACyB,KADd;AAELE,UAAAA,IAAI,EAAE+B;AAFD,SAAP;AAID;AACF;;AAED,QAAI3C,QAAQ,KAAKf,QAAQ,CAACyB,KAA1B,EAAiC;AAC/B,UAAImC,WAAJ,EAAiB;AACf,eAAO;AACL7C,UAAAA,QAAQ,EAAEA,QADL;AAELY,UAAAA,IAAI,EAAE+B;AAFD,SAAP;AAID;;AAED,UAAIC,UAAJ,EAAgB;AACd,eAAO;AACL5C,UAAAA,QAAQ,EAAEf,QAAQ,CAACwB,IADd;AAELG,UAAAA,IAAI,EAAE6B;AAFD,SAAP;AAID;AACF,KA9Ce,CA8Cd;;;AAGF,QAAIK,UAAU,GAAGpD,IAAI,CAACwC,GAAL,CAASrB,QAAQ,CAACvB,KAAT,GAAiBwB,cAAjB,GAAkC6B,SAAS,CAAC9C,KAArD,CAAjB;AACA,QAAIkD,SAAS,GAAGrD,IAAI,CAACwC,GAAL,CAASO,QAAQ,CAAClD,IAAT,GAAgBuB,cAAzB,CAAhB;;AAEA,QAAIgC,UAAU,GAAGC,SAAjB,EAA4B;AAC1B,aAAO;AACL/C,QAAAA,QAAQ,EAAEf,QAAQ,CAACyB,KADd;AAELE,QAAAA,IAAI,EAAE+B;AAFD,OAAP;AAID;;AAED,WAAO;AACL3C,MAAAA,QAAQ,EAAEf,QAAQ,CAACwB,IADd;AAELG,MAAAA,IAAI,EAAE6B;AAFD,KAAP;AAID;;AAED,MAAIO,sBAAsB,GAAGzC,cAAc,CAACP,QAAD,CAA3C;AACA,MAAIiD,OAAJ;AACA,MAAIC,UAAJ;;AAEA,MAAIF,sBAAJ,EAA4B;AAC1BC,IAAAA,OAAO,GAAGP,OAAO,CAAC;AAChB1C,MAAAA,QAAQ,EAAEA,QADM;AAEhBoB,MAAAA,UAAU,EAAEA,UAFI;AAGhBS,MAAAA,UAAU,EAAEA,UAHI;AAIhBD,MAAAA,YAAY,EAAEA;AAJE,KAAD,CAAjB;AAMAsB,IAAAA,UAAU,GAAGR,OAAO,CAAC;AACnB1C,MAAAA,QAAQ,EAAED,cAAc,CAACC,QAAD,CADL;AAEnBoB,MAAAA,UAAU,EAAEA,UAFO;AAGnBS,MAAAA,UAAU,EAAEA,UAHO;AAInBD,MAAAA,YAAY,EAAEA;AAJK,KAAD,CAApB;AAMD,GAbD,MAaO;AACLqB,IAAAA,OAAO,GAAGP,OAAO,CAAC;AAChB1C,MAAAA,QAAQ,EAAED,cAAc,CAACC,QAAD,CADR;AAEhBoB,MAAAA,UAAU,EAAEA,UAFI;AAGhBS,MAAAA,UAAU,EAAEA,UAHI;AAIhBD,MAAAA,YAAY,EAAEA;AAJE,KAAD,CAAjB;AAMAsB,IAAAA,UAAU,GAAGR,OAAO,CAAC;AACnB1C,MAAAA,QAAQ,EAAEA,QADS;AAEnBoB,MAAAA,UAAU,EAAEA,UAFO;AAGnBS,MAAAA,UAAU,EAAEA,UAHO;AAInBD,MAAAA,YAAY,EAAEA;AAJK,KAAD,CAApB;AAMD;;AAED,MAAIuB,gBAAgB,GAAGpC,YAAY,CAACkC,OAAD,EAAUnC,cAAV,CAAnC;AACA,MAAIsC,sBAAsB,GAAGzC,eAAe,CAACuC,UAAD,EAAarC,QAAb,EAAuBC,cAAvB,CAA5C;;AAEA,MAAIkC,sBAAJ,EAA4B;AAC1B,QAAIG,gBAAJ,EAAsB;AACpB,aAAO;AACLnD,QAAAA,QAAQ,EAAEA,QADL;AAELY,QAAAA,IAAI,EAAEqC;AAFD,OAAP;AAID;;AAED,QAAIG,sBAAJ,EAA4B;AAC1B,aAAO;AACLpD,QAAAA,QAAQ,EAAED,cAAc,CAACC,QAAD,CADnB;AAELY,QAAAA,IAAI,EAAEsC;AAFD,OAAP;AAID;AACF;;AAED,MAAI,CAACF,sBAAL,EAA6B;AAC3B,QAAII,sBAAJ,EAA4B;AAC1B,aAAO;AACLpD,QAAAA,QAAQ,EAAEA,QADL;AAELY,QAAAA,IAAI,EAAEsC;AAFD,OAAP;AAID;;AAED,QAAIC,gBAAJ,EAAsB;AACpB,aAAO;AACLnD,QAAAA,QAAQ,EAAED,cAAc,CAACC,QAAD,CADnB;AAELY,QAAAA,IAAI,EAAEqC;AAFD,OAAP;AAID;AACF,GA5IyB,CA4IxB;;;AAGF,MAAII,WAAW,GAAG3D,IAAI,CAACwC,GAAL,CAASrB,QAAQ,CAACxB,MAAT,GAAkByB,cAAlB,GAAmCoC,UAAU,CAACpD,MAAvD,CAAlB;AACA,MAAIwD,QAAQ,GAAG5D,IAAI,CAACwC,GAAL,CAASe,OAAO,CAACzD,GAAR,GAAcsB,cAAvB,CAAf;;AAEA,MAAIuC,WAAW,GAAGC,QAAlB,EAA4B;AAC1B,WAAO;AACLtD,MAAAA,QAAQ,EAAEgD,sBAAsB,GAAGjD,cAAc,CAACC,QAAD,CAAjB,GAA8BA,QADzD;AAELY,MAAAA,IAAI,EAAEsC;AAFD,KAAP;AAID;;AAED,SAAO;AACLlD,IAAAA,QAAQ,EAAEgD,sBAAsB,GAAGhD,QAAH,GAAcD,cAAc,CAACC,QAAD,CADvD;AAELY,IAAAA,IAAI,EAAEqC;AAFD,GAAP;AAID;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASP,OAAT,CAAiBa,KAAjB,EAAwB;AACtB,MAAInC,UAAU,GAAGmC,KAAK,CAACnC,UAAvB;AAAA,MACIpB,QAAQ,GAAGuD,KAAK,CAACvD,QADrB;AAAA,MAEI4B,YAAY,GAAG2B,KAAK,CAAC3B,YAFzB;AAAA,MAGIC,UAAU,GAAG0B,KAAK,CAAC1B,UAHvB;AAIA,MAAIY,QAAQ,GAAGZ,UAAU,CAACtC,IAAX,GAAkBsC,UAAU,CAACvC,KAAX,GAAmB,CAArC,GAAyC8B,UAAU,CAAC9B,KAAX,GAAmB,CAA3E;AACA,MAAIkE,WAAW,GAAG3B,UAAU,CAACrC,GAAX,GAAiB4B,UAAU,CAAC/B,MAA5B,GAAqCuC,YAAvD;AACA,MAAI6B,cAAc,GAAG5B,UAAU,CAAC/B,MAAX,GAAoB8B,YAAzC;AACA,MAAI8B,aAAa,GAAG7B,UAAU,CAAChC,KAAX,GAAmBuB,UAAU,CAAC9B,KAAlD;AACA,MAAIqE,iBAAiB,GAAG9B,UAAU,CAACrC,GAAX,GAAiBqC,UAAU,CAACxC,MAAX,GAAoB,CAArC,GAAyC+B,UAAU,CAAC/B,MAAX,GAAoB,CAArF;;AAEA,UAAQW,QAAR;AACE,SAAKf,QAAQ,CAACwB,IAAd;AACE,aAAOvB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEsC,UAAU,CAACtC,IAAX,GAAkB6B,UAAU,CAAC9B,KAA7B,GAAqCsC,YADjB;AAE1BpC,QAAAA,GAAG,EAAEmE;AAFqB,OAAb,CAAf;;AAKF,SAAK1E,QAAQ,CAACyB,KAAd;AACE,aAAOxB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEsC,UAAU,CAAChC,KAAX,GAAmB+B,YADC;AAE1BpC,QAAAA,GAAG,EAAEmE;AAFqB,OAAb,CAAf;;AAKF,SAAK1E,QAAQ,CAACkB,GAAd;AACE,aAAOjB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEkD,QADoB;AAE1BjD,QAAAA,GAAG,EAAEgE;AAFqB,OAAb,CAAf;;AAKF,SAAKvE,QAAQ,CAACgB,QAAd;AACE,aAAOf,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEsC,UAAU,CAACtC,IADS;AAE1BC,QAAAA,GAAG,EAAEgE;AAFqB,OAAb,CAAf;;AAKF,SAAKvE,QAAQ,CAACoB,SAAd;AACE,aAAOnB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEmE,aADoB;AAE1BlE,QAAAA,GAAG,EAAEgE;AAFqB,OAAb,CAAf;;AAKF;AACA,SAAKvE,QAAQ,CAACmB,MAAd;AACE,aAAOlB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEkD,QADoB;AAE1BjD,QAAAA,GAAG,EAAEiE;AAFqB,OAAb,CAAf;;AAKF,SAAKxE,QAAQ,CAACiB,WAAd;AACE,aAAOhB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEsC,UAAU,CAACtC,IADS;AAE1BC,QAAAA,GAAG,EAAEiE;AAFqB,OAAb,CAAf;;AAKF,SAAKxE,QAAQ,CAACqB,YAAd;AACE,aAAOpB,QAAQ,CAACkC,UAAD,EAAa;AAC1B7B,QAAAA,IAAI,EAAEmE,aADoB;AAE1BlE,QAAAA,GAAG,EAAEiE;AAFqB,OAAb,CAAf;AA7CJ;AAkDD","sourcesContent":["import { Position } from '../../constants';\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\n\nvar makeRect = function makeRect(_ref, _ref2) {\n  var height = _ref.height,\n      width = _ref.width;\n  var left = _ref2.left,\n      top = _ref2.top;\n  var ceiledLeft = Math.ceil(left);\n  var ceiledTop = Math.ceil(top);\n  return {\n    width: width,\n    height: height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  };\n};\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\n\n\nvar flipHorizontal = function flipHorizontal(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT;\n\n    case Position.TOP:\n    default:\n      return Position.BOTTOM;\n\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT;\n\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT;\n\n    case Position.BOTTOM:\n      return Position.TOP;\n\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT;\n  }\n};\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedOnTop = function isAlignedOnTop(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedHorizontal = function isAlignedHorizontal(position) {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {\n  return rect.bottom < viewport.height - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {\n  return rect.top > viewportOffset;\n};\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {\n  return rect.right < viewport.width - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {\n  return rect.left > viewportOffset;\n};\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\n\n\nvar getTransformOrigin = function getTransformOrigin(_ref3) {\n  var dimensions = _ref3.dimensions,\n      position = _ref3.position,\n      rect = _ref3.rect,\n      targetCenter = _ref3.targetCenter;\n  var centerY = Math.round(targetCenter - rect.top);\n\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(dimensions.width, \"px \").concat(centerY, \"px\");\n  }\n\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return \"0px \".concat(centerY, \"px\");\n  }\n\n  var centerX = Math.round(targetCenter - rect.left);\n\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(centerX, \"px \").concat(dimensions.height, \"px \");\n  }\n  /* Syntax: x-offset | y-offset */\n\n\n  return \"\".concat(centerX, \"px 0px \");\n};\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Number} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position, transformOrigin: string }\n */\n\n\nexport default function getFittedPosition(_ref4) {\n  var dimensions = _ref4.dimensions,\n      position = _ref4.position,\n      targetOffset = _ref4.targetOffset,\n      targetRect = _ref4.targetRect,\n      viewport = _ref4.viewport,\n      _ref4$viewportOffset = _ref4.viewportOffset,\n      viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;\n\n  var _getPosition = getPosition({\n    position: position,\n    dimensions: dimensions,\n    targetRect: targetRect,\n    targetOffset: targetOffset,\n    viewport: viewport,\n    viewportOffset: viewportOffset\n  }),\n      finalPosition = _getPosition.position,\n      rect = _getPosition.rect; // Push rect to the right if overflowing on the left side of the viewport.\n\n\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));\n    rect.left = Math.ceil(viewportOffset);\n  } // Push rect to the left if overflowing on the right side of the viewport.\n\n\n  if (rect.right > viewport.width - viewportOffset) {\n    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));\n    rect.left -= delta;\n    rect.right -= delta;\n  } // Push rect down if overflowing on the top side of the viewport.\n\n\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));\n    rect.bottom = Math.ceil(viewportOffset);\n  } // Push rect up if overflowing on the bottom side of the viewport.\n\n\n  if (rect.bottom > viewport.height - viewportOffset) {\n    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));\n\n    rect.top -= _delta;\n    rect.bottom -= _delta;\n  }\n\n  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;\n  var transformOrigin = getTransformOrigin({\n    rect: rect,\n    position: finalPosition,\n    dimensions: dimensions,\n    targetCenter: targetCenter\n  });\n  return {\n    rect: rect,\n    position: finalPosition,\n    transformOrigin: transformOrigin\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\n\nfunction getPosition(_ref5) {\n  var dimensions = _ref5.dimensions,\n      position = _ref5.position,\n      targetOffset = _ref5.targetOffset,\n      targetRect = _ref5.targetRect,\n      viewport = _ref5.viewport,\n      _ref5$viewportOffset = _ref5.viewportOffset,\n      viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;\n  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions\n\n  if (isHorizontal) {\n    var leftRect = getRect({\n      position: Position.LEFT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);\n    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);\n\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position: position,\n          rect: leftRect\n        };\n      }\n\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        };\n      }\n    }\n\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position: position,\n          rect: rightRect\n        };\n      }\n\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        };\n      }\n    } // Default to using the position with the most space\n\n\n    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);\n    var spaceLeft = Math.abs(leftRect.left - viewportOffset);\n\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      };\n    }\n\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    };\n  }\n\n  var positionIsAlignedOnTop = isAlignedOnTop(position);\n  var topRect;\n  var bottomRect;\n\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  }\n\n  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);\n  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);\n\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position: position,\n        rect: topRect\n      };\n    }\n\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      };\n    }\n  }\n\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: position,\n        rect: bottomRect\n      };\n    }\n\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      };\n    }\n  } // Default to most spacious if there is no fit.\n\n\n  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);\n  var spaceTop = Math.abs(topRect.top - viewportOffset);\n\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    };\n  }\n\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @return {Rect} - Rect { width, height, left, top, right, bottom }\n */\n\n\nfunction getRect(_ref6) {\n  var dimensions = _ref6.dimensions,\n      position = _ref6.position,\n      targetOffset = _ref6.targetOffset,\n      targetRect = _ref6.targetRect;\n  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;\n  var alignedTopY = targetRect.top - dimensions.height - targetOffset;\n  var alignedBottomY = targetRect.bottom + targetOffset;\n  var alignedRightX = targetRect.right - dimensions.width;\n  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;\n\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      });\n\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      });\n\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      });\n\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      });\n  }\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport isEmpty from 'lodash.isempty';\nimport uniqBy from 'lodash.uniqby';\nimport FileRejectionReason from '../../../constants/src/FileRejectionReason';\nimport hasValue from '../../../lib/has-value';\nimport { getAcceptedTypesMessage, getFileSizeMessage, getMaxFilesMessage } from './messages';\n/**\n * @typedef {object} FileRejection\n * @property {File} file\n * @property {string} message Informative message to display to the user for why the file was rejected\n * @property {string} reason Error code/enum to denote why the file was rejected\n */\n\n/**\n * Returns a list of objects containing rejected files and why they were rejected based on the provided options\n * @param {File[]} files\n * @param {import('./split-files').SplitFilesOptions | undefined} options\n * @returns {FileRejection[]}\n */\n\nvar getFileRejections = function getFileRejections(files, options) {\n  if (options == null || isEmpty(files)) {\n    return [];\n  }\n\n  var acceptedMimeTypes = options.acceptedMimeTypes,\n      currentCount = options.currentFileCount,\n      maxFiles = options.maxFiles,\n      maxSizeInBytes = options.maxSizeInBytes;\n  var typeRejections = files.map(function (file) {\n    if (isEmpty(acceptedMimeTypes) || acceptedMimeTypes !== null && acceptedMimeTypes !== void 0 && acceptedMimeTypes.some(function (type) {\n      return file.type === type;\n    })) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.InvalidFileType,\n      message: \"This file is not an accepted format. \".concat(getAcceptedTypesMessage(acceptedMimeTypes))\n    };\n  });\n  var sizeRejections = files.map(function (file) {\n    if (maxSizeInBytes == null || maxSizeInBytes === 0 || file.size <= maxSizeInBytes) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.FileTooLarge,\n      message: \"This file is too big. \".concat(getFileSizeMessage(maxSizeInBytes))\n    };\n  });\n  var countRejections = files.map(function (file, index) {\n    if (maxFiles == null) {\n      return;\n    }\n\n    var fileNumber = index + 1;\n\n    if ((currentCount !== null && currentCount !== void 0 ? currentCount : 0) + fileNumber <= maxFiles) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.OverFileLimit,\n      message: getMaxFilesMessage(maxFiles)\n    };\n  }); // Type rejections are arguably more important than size rejections, so those will take priority\n\n  var fileRejections = [].concat(_toConsumableArray(typeRejections), _toConsumableArray(sizeRejections), _toConsumableArray(countRejections)).filter(hasValue);\n  return uniqBy(fileRejections, function (rejection) {\n    return rejection.file;\n  });\n};\n\nexport default getFileRejections;","map":{"version":3,"sources":["D:/0xtest/WifiAssistant/node_modules/evergreen-ui/esm/file-uploader/src/utils/get-file-rejections.js"],"names":["_toConsumableArray","isEmpty","uniqBy","FileRejectionReason","hasValue","getAcceptedTypesMessage","getFileSizeMessage","getMaxFilesMessage","getFileRejections","files","options","acceptedMimeTypes","currentCount","currentFileCount","maxFiles","maxSizeInBytes","typeRejections","map","file","some","type","reason","InvalidFileType","message","concat","sizeRejections","size","FileTooLarge","countRejections","index","fileNumber","OverFileLimit","fileRejections","filter","rejection"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport isEmpty from 'lodash.isempty';\nimport uniqBy from 'lodash.uniqby';\nimport FileRejectionReason from '../../../constants/src/FileRejectionReason';\nimport hasValue from '../../../lib/has-value';\nimport { getAcceptedTypesMessage, getFileSizeMessage, getMaxFilesMessage } from './messages';\n/**\n * @typedef {object} FileRejection\n * @property {File} file\n * @property {string} message Informative message to display to the user for why the file was rejected\n * @property {string} reason Error code/enum to denote why the file was rejected\n */\n\n/**\n * Returns a list of objects containing rejected files and why they were rejected based on the provided options\n * @param {File[]} files\n * @param {import('./split-files').SplitFilesOptions | undefined} options\n * @returns {FileRejection[]}\n */\n\nvar getFileRejections = function getFileRejections(files, options) {\n  if (options == null || isEmpty(files)) {\n    return [];\n  }\n\n  var acceptedMimeTypes = options.acceptedMimeTypes,\n      currentCount = options.currentFileCount,\n      maxFiles = options.maxFiles,\n      maxSizeInBytes = options.maxSizeInBytes;\n  var typeRejections = files.map(function (file) {\n    if (isEmpty(acceptedMimeTypes) || acceptedMimeTypes !== null && acceptedMimeTypes !== void 0 && acceptedMimeTypes.some(function (type) {\n      return file.type === type;\n    })) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.InvalidFileType,\n      message: \"This file is not an accepted format. \".concat(getAcceptedTypesMessage(acceptedMimeTypes))\n    };\n  });\n  var sizeRejections = files.map(function (file) {\n    if (maxSizeInBytes == null || maxSizeInBytes === 0 || file.size <= maxSizeInBytes) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.FileTooLarge,\n      message: \"This file is too big. \".concat(getFileSizeMessage(maxSizeInBytes))\n    };\n  });\n  var countRejections = files.map(function (file, index) {\n    if (maxFiles == null) {\n      return;\n    }\n\n    var fileNumber = index + 1;\n\n    if ((currentCount !== null && currentCount !== void 0 ? currentCount : 0) + fileNumber <= maxFiles) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.OverFileLimit,\n      message: getMaxFilesMessage(maxFiles)\n    };\n  }); // Type rejections are arguably more important than size rejections, so those will take priority\n\n  var fileRejections = [].concat(_toConsumableArray(typeRejections), _toConsumableArray(sizeRejections), _toConsumableArray(countRejections)).filter(hasValue);\n  return uniqBy(fileRejections, function (rejection) {\n    return rejection.file;\n  });\n};\n\nexport default getFileRejections;"]},"metadata":{},"sourceType":"module","externalDependencies":[]}